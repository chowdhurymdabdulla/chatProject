
const fs = require("fs");
const { scanPath, scanPathWatch } = require('mn-node-utils/scanPath');
const pickByMap = require('mn-utils/pickByMap');
const finallyAll = require('mn-utils/finallyAll');

const parserProvider = require("minimalist-notation/mnParserProvider");
const compileProvider = require("minimalist-notation/mnCompileProvider");

const getAttrs = parserProvider.getAttrs;
const {
  forIn,
  map,
  reduce,
  isArray,
  isObject,
  flags,
  eachApply,
  extend,
  merge,
  noop,
  isEmpty
} = require("mn-utils");

const defaultSettings = exports.defaultSettings = {
  path: './',
  output: './mn.styles.css',
  include: /^.*\.(html?|(js|ts)x?|vue)$/,
  exclude: /\/node_modules\/|\.tmp\./,
  attrs: [ 'm' ],
  presets: [
    require('mn-presets/medias'),
  	require('mn-presets/prefixes'),
  	require('mn-presets/styles'),
  	require('mn-presets/states'),
  	require('mn-presets/theme')
  ]
};

exports.compileSource = (__options) => {
  const settings = merge([ defaultSettings, __options ]);

  const { path, entry } = settings;
  isObject(entry)
    ? parseSource(path, settings, entry)
    : parseSource(path, settings, {
        [settings.entry || settings.path]: settings
      });
};

const __sort = (a, b) => b.count - a.count;

const __onError = (err) => {
  err && console.error(err);
};
const regexpPathSplit = /[\/\\]+/;
const checkPath = (filename) => {
  const parts = filename.split(regexpPathSplit);
  let path = parts.shift();
  parts.forEach((partName) => {
    if (!fs.existsSync(path)) fs.mkdirSync(path);
    path += '/' + partName;
  });
  return filename;
};


const __parseSource = ({ path, attrs, each, callback, watch, exclude }) => {
  finallyAll((inc, dec) => {
    inc();
    const __parse = parserProvider(attrs);
    (watch ? scanPathWatch : scanPath)({
      path,
      exclude,
      callback: dec,
      each: (eventType, path) => {
        each(path, (setter) => {
          if (eventType === 'remove') return setter(null, 0);
          inc();
          fs.readFile(path, 'utf8', (err, text) => {
            const dst = {};
            setter(dst, __parse(dst, text || ''));
            dec();
          });
        })
      }
    })
  }, callback);
};

const parseSource = (path, commonOptions, entries) => {
  const finish = commonOptions.finish || noop;
  const each = commonOptions.each || noop;
  const attrs = commonOptions.attrs || [];
  const presets = commonOptions.presets || [];
  const selectorPrefix = commonOptions.selectorPrefix || '';
  const { include, exclude, watch } = commonOptions;

  const allAttrsMap = getAttrsMap(attrs);
  const handlersMap = {};
  const excludesMap = {};
  forIn(entries, (entryOptions, name) => {
    const attrsMap = getAttrsMap(entryOptions.attrs, attrs);
    extend(allAttrsMap, attrsMap);
    const data = {};
    const _include = getInclude(entryOptions.include || include);
    const _exclude = excludesMap[name] = getInclude(entryOptions.exclude || exclude);
    handlersMap[name] = {
      isExclude: wrapExclude(_exclude, _include),
      set: setDataProvider(data, attrsMap),
      build: buildProvider(data, entryOptions.output || name, compileProvider({
        presets: entryOptions.presets || presets,
        selectorPrefix: entryOptions.selectorPrefix || selectorPrefix
      }))
    };
  });

  let hasFinished;
  __parseSource({
    watch,
    path: path,
    attrs: Object.keys(allAttrsMap),
    exclude: (path) => {
      for (let name in excludesMap) {
        if (!excludesMap[name](path)) return false;
      }
      return true;
    },
    each: (path, parse) => {
      let cache, started, finished, watchers = [];
      forIn(handlersMap, ({ isExclude, set, build }, name) => {
        if (isExclude(path)) return;
        const __build = () => {
          set(path, cache);
          hasFinished && build();
        };
        if (finished) return __build();
        if (started) {
          watchers.push(__build);
        } else {
          started = true;
          parse((output, count) => {
            each(path, count);
            cache = output;
            finished = true;
            eachApply(watchers);
            __build();
          });
        }
      });
    },
    callback: () => {
      hasFinished = true;
      forIn(handlersMap, ({ build }) => {
        build();
      });
      finish();
    }
  })

};

const getAttrsMap = (entryAttrs, commonAttrs) => flags(getAttrs(entryAttrs) || getAttrs(commonAttrs))
const wrapExclude = (exclude, include) => {
  return (path) => {
    if (exclude(path)) return true;
    if (include(path)) return false;
    return true;
  };
};

const getInclude = (include) => {
  return include ? (isArray(include) ? (path) => {
    for (i = include.length; i--;) {
      if ((v = include[i]) && v.test(path)) return true;
    }
  } : (path) => include.test(path)) : noop;
};

const regexpCSS = /.*\.css$/;
const __iterateeAttrsMap = (essences) => Object.values(essences).sort(__sort);
const buildProvider = (data, name, compile) => {
  regexpCSS.test(name) || (name += '.css');
  checkPath(name);
  const metricsFilesPath = name + '.mn-metrics-files.json';
  const metricsPath = name + '.mn-metrics.json';
  const onFinally = (err) => {
    err ? console.error(err) : console.log('mn output:', name);
  };
  return () => {
    const mergedData = mergeData(data);
    fs.writeFile(name, compile(mergedData), onFinally);

    fs.writeFile(metricsFilesPath, JSON.stringify(reduce(data, (dst, attrsMap, path) => {
      isEmpty(attrsMap) || (dst[path] = map(attrsMap, __iterateeAttrsMap));
      return dst;
    }, {}), null, '  '), __onError);

    fs.writeFile(metricsPath, JSON.stringify(map(mergedData, __iterateeAttrsMap), null, '  '), __onError);
  };
};

const mergeData = (pathsMap) => {
  const attrsMap = {};
  const attrsIteratee = (essencesNames, attrName) => {
    const values = attrsMap[attrName] || (attrsMap[attrName] = {});
    forIn(essencesNames, (item, name) => {
      (values[name] || (values[name] = {
        name, count: 0
      })).count += item.count;
    });
  };
  forIn(pathsMap, (srcAttrsMap, path) => {
    forIn(srcAttrsMap, attrsIteratee);
  });
  return attrsMap;
};


const setDataProvider = (data, attrsMap) => {
  return (path, src) => {
    if (src) {
      pickByMap(src, attrsMap, data[path] = {});
    } else {
      delete data[path];
    }
  };
};
